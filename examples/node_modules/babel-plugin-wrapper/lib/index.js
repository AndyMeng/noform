"use strict";

var _require = require('@babel/helper-module-imports'),
    addDefault = _require.addDefault;

function camel2Underline(_str) {
  var str = _str[0].toLowerCase() + _str.substr(1);

  return str.replace(/([A-Z])/g, function ($1) {
    return "_".concat($1.toLowerCase());
  });
}

function libNameFormat(name) {
  return "_lib_" + name.toLowerCase();
}

function requireLibNameFormat(name) {
  return name.replace(/[A-Z]/g, function (s1, s2) {
    return (s2 !== 0 ? '-' : '') + s1.toLowerCase();
  });
}

function wrapperFormat(name) {
  return '_' + camel2Underline(name.replace(/\//g, '_'));
}

function kindResultFormat(kind, name) {
  return '_' + kind + '_result_' + name;
}

module.exports = function (babel) {
  var t = babel.types;
  var wrapperPrefix = 'noform/lib/wrapper/';
  var dialogPrefix = 'noform/lib/dialog/';
  var importTraverseObject = {
    ExpressionStatement: function ExpressionStatement(path) {// debugger;
    },
    ImportDeclaration: function ImportDeclaration(path, data) {
      var _data$opts = data.opts,
          opts = _data$opts === void 0 ? {} : _data$opts,
          runtimeData = data.runtimeData;
      var source = '';
      var target = [];
      var sourceNode = path.node.source;
      var specifiersNode = path.node.specifiers;

      if (t.isStringLiteral(sourceNode)) {
        source = sourceNode.value;
      } // is noform wrapper 


      var specificParams = [];
      var specificRefs = [];

      if (source.startsWith(wrapperPrefix)) {
        // eg. noform/dist/wrapper/antd
        var sourceKind = source.split(wrapperPrefix)[1];
        var kindResult = kindResultFormat('wrapper', sourceKind);

        if (Array.isArray(specifiersNode)) {
          specifiersNode.forEach(function (item) {
            if (t.isImportSpecifier(item)) {
              target.push(item.local.name);
              if (!runtimeData[source]) runtimeData[source] = {};
              runtimeData[source][item.local.name] = {
                parent: path
              }; // paramters for wrapper
              // eg. _lib_input

              var formatLibName = libNameFormat(item.local.name);
              specificParams.push(t.objectProperty(t.identifier(item.local.name), t.identifier(formatLibName)));
              specificRefs.push(t.variableDeclaration('const', [t.variableDeclarator(t.identifier(item.local.name), t.memberExpression(t.identifier(kindResult), t.identifier(item.local.name)))]));
            }
          });
        }

        path.replaceWithMultiple([t.variableDeclaration('const', [t.variableDeclarator(t.identifier(kindResult), t.callExpression(t.identifier(wrapperFormat(source)), [t.objectExpression(specificParams)]))])].concat(specificRefs));
      } else if (source.startsWith(dialogPrefix)) {
        // eg. noform/dist/dialog/antd
        var _sourceKind = source.split(dialogPrefix)[1];

        var _kindResult = kindResultFormat('dialog', _sourceKind);

        ['Button', 'Modal'].forEach(function (localName) {
          target.push(localName);
          if (!runtimeData[source]) runtimeData[source] = {};
          runtimeData[source][localName] = {
            parent: path
          }; // paramters for wrapper
          // eg. { Button: _lib_button }

          var formatLibName = libNameFormat(localName);
          specificParams.push(t.objectProperty(t.identifier(localName), t.identifier(formatLibName)));
        }); // eg. const _dialog_result_antd = _noform_dist_dialog_antd(...params)            

        var originName = '';

        if (path.node && path.node.specifiers && path.node.specifiers[0] && path.node.specifiers[0].local && path.node.specifiers[0].local.name) {
          originName = path.node.specifiers[0].local.name;
        }

        path.replaceWithMultiple([t.variableDeclaration('const', [t.variableDeclarator(t.identifier(originName || _kindResult), t.callExpression(t.identifier(wrapperFormat(source)), [t.objectExpression(specificParams)]))])]);
      } else {
        path.skip();
      }
    }
  };

  function handleAdd(file, runtimeData) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var prefix = 'lib';
    var wrapperLibNames = Object.keys(runtimeData);
    var registeredComponent = [];
    wrapperLibNames.forEach(function (name) {
      var libDeps = runtimeData[name]; // console.log('====[inner](' + name + ')', Object.keys(libDeps));

      var resultLibName = '';

      if (name.startsWith(wrapperPrefix)) {
        resultLibName = name.split(wrapperPrefix)[1];
      } else if (name.startsWith(dialogPrefix)) {
        resultLibName = name.split(dialogPrefix)[1];
      }

      Object.keys(libDeps).forEach(function (libName) {
        if (registeredComponent.indexOf(libName) === -1) {
          registeredComponent.push(libName);
          var lowerLibName = requireLibNameFormat(libName);
          var sourcePath = "".concat(resultLibName, "/").concat(prefix, "/").concat(lowerLibName); // console.log('===[*single*]', sourcePath, libNameFormat(libName));

          addDefault(file.path, sourcePath, {
            nameHint: libNameFormat(libName)
          });
        }
      });
      addDefault(file.path, name, {
        nameHint: wrapperFormat(name)
      });
    });
  }

  return {
    pre: function pre(path) {
      this.runtimeData = {};
    },
    visitor: {
      Program: function Program(path, data) {
        path.traverse(importTraverseObject, {
          opts: data.opts,
          runtimeData: this.runtimeData
        });
        handleAdd(data.file, this.runtimeData, data.opts);
      }
    },
    post: function post() {
      delete this.runtimeData;
    }
  };
};